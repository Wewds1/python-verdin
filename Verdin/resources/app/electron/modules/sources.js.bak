// This module handles camera management, FFmpeg preprocessing,
// and interaction with the MediaMTX API.
const { spawn } = require('child_process'); // Required for spawning FFmpeg processes
const db = require('../model/db'); // Your database connection

// Base URL for the MediaMTX Control API
const API_BASE = 'http://localhost:9997/v3/config/paths';

// Define the MediaMTX RTSP port.
// This should match the port MediaMTX is listening on for RTSP streams.
// Default is often 8554. You can set this via an environment variable
// (e.g., MEDIA_MTX_RTSP_PORT=8554 node your_app.js) or hardcode it.
const MEDIA_MTX_RTSP_PORT = process.env.MEDIA_MTX_RTSP_PORT || 8554;

// --- Concurrency Control for FFmpeg Processes ---
// Define the maximum number of FFmpeg processes that can run simultaneously.
// Adjust this value based on your system's resources (CPU, RAM).
// A higher number allows more concurrent streams but requires more CPU/RAM.
const MAX_CONCURRENT_FFMPEG_PROCESSES = 30; // Increased as per request
let currentFfmpegProcesses = 0; // Counter for currently active FFmpeg processes
const ffmpegQueue = []; // Queue for pending FFmpeg tasks

// A map to store active FFmpeg child processes. This allows us to manage
// and kill them when the application exits or a camera is removed.
const activeFfmpegProcesses = new Map();

/**
 * Sanitizes a camera name to create a suitable path identifier for MediaMTX.
 * Converts to lowercase, trims whitespace, and removes non-alphanumeric,
 * non-underscore, non-hyphen, non-dot characters.
 * @param {string} name - The original camera name.
 * @returns {string} The sanitized path name.
 */
function sanitizePathName(name) {
    if (typeof name !== 'string' || name.trim() === '') {
        return '';
    }
    // Convert to lowercase, trim, and remove all whitespace.
    // Allows alphanumeric, underscore, hyphen, dot.
    return name.toLowerCase().trim().replace(/\s+/g, '').replace(/[^a-z0-9_.-]/g, '');
}

/**
 * Fetches all camera sources from the database.
 * @returns {Promise<Array<Object>>} A promise that resolves with an array of source objects.
 */
function getAllSources() {
    return new Promise((resolve, reject) => {
        db.all('SELECT * FROM sources JOIN clients ON sources.client_id = clients.client_id', (err, rows) => {
            if (err) {
                console.error('Database error while fetching sources:', err);
                return reject(new Error(`Failed to fetch sources from database: ${err.message}`));
            }
            // Resolve with rows (will be an empty array if no sources are found)
            return resolve(rows);
        });
    });
}

/**
 * Executes the core logic for adding a camera, including spawning FFmpeg
 * and configuring MediaMTX. This function is now called by the queue processor.
 * @param {string} name - The display name of the camera.
 * @param {string} rtspUrl - The original RTSP URL of the camera.
 * @returns {Promise<Object>} A promise that resolves with success status and path name.
 */
async function executeAddCamera(name, rtspUrl) {
    const pathName = sanitizePathName(name);
    if (!pathName) {
        throw new Error('Camera name is invalid or results in an empty path after sanitization.');
    }

    let processedRtspUrl = rtspUrl;
    try {
        // Parse the original RTSP URL to ensure username/password are correctly encoded.
        // This helps in handling special characters in credentials.
        const urlObj = new URL(rtspUrl);
        const newUrlObj = new URL(urlObj.protocol + "//" + urlObj.hostname + (urlObj.port ? `:${urlObj.port}` : '') + urlObj.pathname + urlObj.search + urlObj.hash);
        if (urlObj.username) {
            newUrlObj.username = urlObj.username;
        }
        if (urlObj.password) {
            newUrlObj.password = urlObj.password;
        }
        processedRtspUrl = newUrlObj.href;
        console.log(`Original RTSP URL for FFmpeg input: ${processedRtspUrl}`);
    } catch (e) {
        console.warn(`RTSP URL "${rtspUrl}" could not be parsed or re-encoded. Using as is. Error: ${e.message}`);
    }

    // Define the internal RTSP path where FFmpeg will push the processed stream.
    // MediaMTX will then pull from this path.
    const internalRtspPath = `${pathName}_processed`;
    const internalRtspUrl = `rtsp://localhost:${MEDIA_MTX_RTSP_PORT}/${internalRtspPath}`;

    // --- Spawn FFmpeg process ---
    // This configuration uses FFmpeg's stream copy feature for video (-c:v copy).
    // This means the video stream is copied directly from the input without re-encoding,
    // retaining its original compression and quality.
    // Audio is still re-encoded to Opus for WebRTC compatibility.
    // IMPORTANT: The original video codec MUST be compatible with MediaMTX and WebRTC
    // (typically H.264, VP8, or VP9) for this to work without MediaMTX transcoding.
    const ffmpegArgs = [
        '-loglevel', 'error',           // Only show error messages from FFmpeg
        '-rtsp_transport', 'tcp',       // Use TCP for RTSP transport for better reliability over UDP.
        '-i', processedRtspUrl,         // Input: The original RTSP stream URL. FFmpeg will try to auto-detect its format.
        '-map', '0:v:0',                // Explicitly select the first video stream from the input.
        '-c:v', 'copy',                 // Video codec: 'copy' retains the original video stream without re-encoding.
        // Removed video encoding-specific options as they are not applicable with '-c:v copy':
        '-vf', 'scale=-1:720,format=nv12', // No scaling or format conversion when copying
        '-r', '30',                     // No frame rate conversion when copying
        '-preset', 'p5',
        '-tune', 'll',
        '-b:v', '1500k',
        '-maxrate', '2M',
        '-bufsize', '4M',
        '-g', '60',
        '-keyint_min', '60',
        '-c:a', 'libopus',              // Audio codec: Opus. This is the recommended audio codec for WebRTC.
        '-b:a', '96k',                  // Audio bitrate: 96 kbps. Adjust for desired audio quality.
        '-f', 'rtsp',                   // Output format: RTSP. FFmpeg pushes the processed stream as an RTSP stream.
        internalRtspUrl                 // Output URL: The local MediaMTX path where FFmpeg will push the stream.
    ];

    console.log(`Spawning FFmpeg for ${pathName} with command: ffmpeg ${ffmpegArgs.join(' ')}`);

    const ffmpegProcess = spawn('ffmpeg', ffmpegArgs, {
        stdio: ['ignore', 'pipe', 'pipe'] // Ignore stdin, pipe stdout/stderr for logging
    });

    // Log FFmpeg's standard output
    ffmpegProcess.stdout.on('data', (data) => {
        console.log(`FFmpeg stdout for ${pathName}: ${data.toString().trim()}`);
    });

    // Log FFmpeg's standard error (FFmpeg often logs progress here, e.g., frame stats)
    ffmpegProcess.stderr.on('data', (data) => {
        console.error(`FFmpeg stderr for ${pathName}: ${data.toString().trim()}`);
    });

    // Handle FFmpeg process closure
    ffmpegProcess.on('close', (code) => {
        if (code !== 0) {
            console.error(`FFmpeg process for ${pathName} exited with code ${code}`);
            // In a production scenario, you might want to implement a retry mechanism here.
        } else {
            console.log(`FFmpeg process for ${pathName} closed successfully.`);
        }
        // Remove from our active processes map if it closes
        activeFfmpegProcesses.delete(pathName);
        currentFfmpegProcesses--; // Decrement active process count
        processNextFfmpegTask(); // Try to process the next task in the queue
    });

    // Handle errors when spawning FFmpeg (e.g., ffmpeg executable not found, permissions issues)
    ffmpegProcess.on('error', (err) => {
        console.error(`Failed to start FFmpeg process for ${pathName}: ${err.message}`);
        // If FFmpeg fails to start, we should not add the camera to MediaMTX.
        // This error will be caught by the outer try-catch.
        currentFfmpegProcesses--; // Decrement active process count
        processNextFfmpegTask(); // Try to process the next task in the queue
    });

    // Store the FFmpeg process reference in our map
    activeFfmpegProcesses.set(pathName, ffmpegProcess);
    currentFfmpegProcesses++; // Increment active process count
    console.log(`FFmpeg process spawned for ${pathName} with PID: ${ffmpegProcess.pid}. Active processes: ${currentFfmpegProcesses}`);


    // --- Configure MediaMTX to consume the internal RTSP stream ---
    // This is the path clients will connect to (e.g., rtsp://localhost:8554/your_camera_name)
    const url = `${API_BASE}/add/${encodeURIComponent(pathName)}`;

    const res = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            source: internalRtspUrl, // MediaMTX will now pull from our local FFmpeg instance
            // runOnDemand is not needed here as FFmpeg is already running
        })
    });
    const text = await res.text();

    if (!res.ok) {
        console.error('Control API error body:', text);
        // If MediaMTX add fails, kill the FFmpeg process we just started
        ffmpegProcess.kill();
        activeFfmpegProcesses.delete(pathName);
        currentFfmpegProcesses--; // Decrement active process count
        processNextFfmpegTask(); // Try to process the next task in the queue
        throw new Error(`Add failed: ${res.status} ${res.statusText} - MediaMTX response: ${text}`);
    }
    if (!text) {
        // An empty response body from MediaMTX usually indicates success for 'add'
        console.log(`Path "${pathName}" added to MediaMTX, sourcing from FFmpeg at "${internalRtspUrl}".`);
        return { success: true, pathName: pathName, message: `Path "${pathName}" added successfully.` };
    }
    try {
        // If MediaMTX returns JSON on success, parse and return it
        return JSON.parse(text);
    } catch (err) {
        console.error('Invalid JSON response from MediaMTX:', text, err);
        // Even if JSON parsing fails, if res.ok is true, it might still be a success.
        // However, for robustness, we'll treat it as an error here.
        ffmpegProcess.kill();
        activeFfmpegProcesses.delete(pathName);
        currentFfmpegProcesses--; // Decrement active process count
        processNextFfmpegTask(); // Try to process the next task in the queue
        throw new Error('Invalid JSON in Control API response');
    }
}

/**
 * Adds a camera task to the queue for processing.
 * @param {string} name - The display name of the camera.
 * @param {string} rtspUrl - The original RTSP URL of the camera.
 * @returns {Promise<Object>} A promise that resolves when the task is processed.
 */
async function addCamera(name, rtspUrl) {
    return new Promise((resolve, reject) => {
        ffmpegQueue.push({ name, rtspUrl, resolve, reject });
        console.log(`Queued camera "${name}". Queue size: ${ffmpegQueue.length}`);
        processNextFfmpegTask(); // Attempt to process the queue
    });
}

/**
 * Processes the next task in the FFmpeg queue if the concurrency limit allows.
 */
function processNextFfmpegTask() {
    if (currentFfmpegProcesses < MAX_CONCURRENT_FFMPEG_PROCESSES && ffmpegQueue.length > 0) {
        const { name, rtspUrl, resolve, reject } = ffmpegQueue.shift(); // Get the next task
        console.log(`Starting FFmpeg process for "${name}". Active processes: ${currentFfmpegProcesses}/${MAX_CONCURRENT_FFMPEG_PROCESSES}`);
        executeAddCamera(name, rtspUrl)
            .then(resolve)
            .catch(reject);
    } else {
        console.log(`FFmpeg queue idle. Active: ${currentFfmpegProcesses}/${MAX_CONCURRENT_FFMPEG_PROCESSES}, Queued: ${ffmpegQueue.length}`);
    }
}

/**
 * Removes a camera path from MediaMTX and kills its associated FFmpeg process.
 * @param {string} name - The display name of the camera to remove.
 * @returns {Promise<Object>} A promise that resolves with success status and path name.
 */
async function removeCamera(name) {
    const pathName = sanitizePathName(name);
    if (!pathName) {
        throw new Error('Camera name is invalid or results in an empty path after sanitization for removal.');
    }

    // Attempt to kill the associated FFmpeg process first
    const ffmpegProcess = activeFfmpegProcesses.get(pathName);
    if (ffmpegProcess) {
        console.log(`Killing FFmpeg process for ${pathName} (PID: ${ffmpegProcess.pid}) before removing from MediaMTX.`);
        ffmpegProcess.kill(); // Send SIGTERM to the process
        activeFfmpegProcesses.delete(pathName); // Remove from our map
        currentFfmpegProcesses--; // Decrement active process count
        processNextFfmpegTask(); // Try to process the next task in the queue
    } else {
        console.warn(`No active FFmpeg process found for ${pathName}. It might have already exited or was not started by this app.`);
    }

    // Now, remove the path from MediaMTX configuration
    const url = `${API_BASE}/delete/${encodeURIComponent(pathName)}`;
    const res = await fetch(url, { method: 'DELETE' });
    const text = await res.text();
    if (!res.ok) {
        console.error('Control API error body:', text);
        throw new Error(`Remove failed: ${res.status} ${res.statusText}`);
    }
    console.log(`Path "${pathName}" removed from MediaMTX.`);
    return { success: true, pathName: pathName, message: `Path "${pathName}" removed successfully.` };
}

/**
 * Fetches the currently configured paths from MediaMTX.
 * @returns {Promise<Object>} A promise that resolves with the MediaMTX paths configuration.
 */
async function getMediaMTXConfiguredPaths() {
    const listConfiguredPathsUrl = `${API_BASE}/list`;

    try {
        const res = await fetch(listConfiguredPathsUrl);
        const text = await res.text(); // Get text first for better error reporting
        if (!res.ok) {
            console.error('MediaMTX API error fetching configured paths list. Status:', res.status, 'Body:', text);
            throw new Error(`Failed to fetch configured paths list from MediaMTX: ${res.status} ${res.statusText}`);
        }
        if (!text) {
            console.warn('MediaMTX API returned empty body for configured paths list. Assuming no paths configured.');
            return { items: {} }; // Return a structure similar to an empty list
        }
        try {
            const data = JSON.parse(text);
            return data; // Expected format: { items: { "pathName": { "name": "pathName", "conf": {...} ... } } }
        } catch (parseError) {
            console.error('Invalid JSON response when fetching configured paths list:', text, parseError);
            throw new Error('Invalid JSON in MediaMTX API response for configured paths list.');
        }
    } catch (fetchError) {
        console.error('Error fetching configured paths list from MediaMTX:', fetchError.message);
        throw fetchError; // Re-throw the error to be caught by the caller
    }
}

// Export functions if this file is a module
module.exports = { addCamera, removeCamera, getAllSources, getMediaMTXConfiguredPaths };
